{
    "sourceFile": "CH579EVT/EVT/EXAM/USB/Device/CH579EVT_USB_DISK_TEST/BLE/ch57x_ble_uart_mrs_app_only_test/app/peripheral_main.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1677078262329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1677078292194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,9 @@\n {\r\n     SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n     PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n     DelayMs(5);\r\n-\r\n+    \r\n     app_uart_init();\r\n     app_led1_init();\r\n     app_key1_init();\r\n \r\n"
                },
                {
                    "date": 1677078298425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,299 @@\n+/********************************** (C) COPYRIGHT *******************************\r\n+ * File Name          : main.c\r\n+ * Author             : WCH\r\n+ * Version            : V1.1\r\n+ * Date               : 2019/11/05\r\n+ * Description        : 外设从机应用主函数及任务系统初始化\r\n+ *******************************************************************************/\r\n+\r\n+/******************************************************************************/\r\n+/* 头文件包含 */\r\n+\r\n+#include \"CH57x_common.h\"\r\n+#include \"ch57x_usb_device_msc.h\"\r\n+#include \"ff.h\"\r\n+#include \"bsp_device.h\"\r\n+#include \"hal_spi.h\"\r\n+#include \"bsp_spi.h\"\r\n+#include \"bsp_log.h\"\r\n+#include \"app_flash.h\"\r\n+#include \"app_uart.h\"\r\n+#include \"app_led.h\"\r\n+#include \"app_key.h\"\r\n+#include \"hal_device.h\"\r\n+\r\n+FATFS fs;          /* FatFs文件系统对象 */\r\n+FIL fnew;          /* 文件对象 */\r\n+FRESULT res_flash; /* 文件操作结果 */\r\n+UINT fnum;         /* 文件成功读写数量 */\r\n+UINT8 uart0_read_len = 0;\r\n+UINT8 uart0_read_flag = 0;\r\n+UINT8 uart0_read_timeout = 0;\r\n+UINT8 uart0_read_buf[31] = {0};\r\n+BYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\n+BYTE WriteBuffer[] =         /* 写缓冲区*/\r\n+    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\n+BYTE WriteBuffer2[] = /* 写缓冲区*/\r\n+    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\n+UINT8 buf[512];\r\n+void DebugInit(void)\r\n+{\r\n+#if DEBUG == Debug_UART1\r\n+    GPIOA_SetBits(bTXD1);\r\n+    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n+    UART1_DefInit();\r\n+#elif DEBUG == Debug_UART0\r\n+    GPIOB_SetBits(bTXD0);\r\n+    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n+    GPIOB_SetBits(bRXD0);\r\n+    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n+\r\n+    UART0_DefInit();\r\n+    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n+    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n+    NVIC_EnableIRQ(UART0_IRQn);\r\n+#endif\r\n+}\r\n+\r\n+UINT8 work[4096];\r\n+int main()\r\n+{\r\n+    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n+    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n+    DelayMs(5);\r\n+\r\n+extern void bsp_key_register(void);\r\n+extern void bsp_key_register(void);\r\n+\r\n+    app_uart_init();\r\n+    app_led1_init();\r\n+    app_key1_init();\r\n+\r\n+    int led1_fd = bsp_device_open(\"led1\", 0);\r\n+    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n+    int key1_fd = bsp_device_open(\"key1\", 0);\r\n+\r\n+    hal_led_data_buff_t led_data = {\r\n+        .status = 1,\r\n+    };\r\n+    hal_uart_data_buff_t uart_msg = {\r\n+        .buff = WriteBuffer2,\r\n+        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n+    };\r\n+\r\n+    bsp_device_write(led1_fd, &led_data, 0);\r\n+    bsp_device_write(uart_fd, &uart_msg, 0);\r\n+\r\n+    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n+\r\n+    res_flash = f_mount(&fs, \"0:\", 1);\r\n+\r\n+    /*----------------------- 格式化测试 -----------------*/\r\n+    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n+    if (res_flash == FR_NO_FILESYSTEM)\r\n+    {\r\n+        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n+        /* 格式化 */\r\n+        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n+\r\n+        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n+\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n+            /* 格式化后，先取消挂载 */\r\n+            res_flash = f_mount(NULL, \"0:\", 1);\r\n+            /* 重新挂载\t*/\r\n+            res_flash = f_mount(&fs, \"0:\", 1);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"FLASH format error\\r\\n\");\r\n+            while (1)\r\n+                ;\r\n+        }\r\n+    }\r\n+    else if (res_flash != FR_OK)\r\n+    {\r\n+        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n+        app_flash_erase_all_flash();\r\n+        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n+        while (1)\r\n+            ;\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n+    }\r\n+\r\n+    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n+    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n+    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n+    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n+    if (res_flash == FR_OK)\r\n+    {\r\n+        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n+        /* 将指定存储区内容写入到文件内 */\r\n+        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n+            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n+        }\r\n+        /* 不再读写，关闭文件 */\r\n+        f_close(&fnew);\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"open/create file error\\r\\n\");\r\n+    }\r\n+\r\n+    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n+    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n+    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n+    if (res_flash == FR_OK)\r\n+    {\r\n+        LOG_INFO(\"open file ok\\r\\n\");\r\n+        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n+            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n+        }\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"open file error\\r\\n\");\r\n+    }\r\n+    /* 不再读写，关闭文件 */\r\n+    f_close(&fnew);\r\n+\r\n+    /* 不再使用文件系统，取消挂载文件系统 */\r\n+    f_mount(NULL, \"0:\", 1);\r\n+\r\n+    pEP0_RAM_Addr = EP0_Databuf;\r\n+    pEP1_RAM_Addr = EP1_Databuf;\r\n+    USB_DeviceInit();\r\n+    NVIC_EnableIRQ(USB_IRQn);\r\n+\r\n+    while (1)\r\n+    {\r\n+\r\n+        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n+        {\r\n+            DelayMs(20);\r\n+            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n+            {\r\n+                bsp_device_write(uart_fd, &uart_msg, 0);\r\n+                res_flash = f_mount(&fs, \"0:\", 1);\r\n+                if (res_flash == FR_OK)\r\n+                {\r\n+                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n+                }\r\n+                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n+                if (res_flash == FR_OK)\r\n+                {\r\n+                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n+                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n+                    if (res_flash == FR_OK)\r\n+                    {\r\n+                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n+                    }\r\n+                }\r\n+                while (1)\r\n+                {\r\n+                    if (uart0_read_flag == 1)\r\n+                    {\r\n+                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n+                        if (res_flash > 0)\r\n+                        {\r\n+                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n+                            f_close(&fnew);\r\n+                            f_mount(NULL, \"0:\", 1);\r\n+                        }\r\n+                        else\r\n+                        {\r\n+                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n+                        }\r\n+                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n+                        uart0_read_len = 0;\r\n+                        uart0_read_flag = 0;\r\n+                        break;\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        DelayMs(20);\r\n+                        uart0_read_timeout++;\r\n+                        if (uart0_read_timeout > 10)\r\n+                        {\r\n+                            uart0_read_timeout = 0;\r\n+                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n+                            uart0_read_len = 0;\r\n+                            uart0_read_flag = 0;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void UART0_IRQHandler(void)\r\n+{\r\n+    UINT8 i;\r\n+    switch (UART0_GetITFlag())\r\n+    {\r\n+    case UART_II_LINE_STAT: // 线路状态错误\r\n+        UART0_GetLinSTA();\r\n+        LOG_INFO(\"UART0 LINE ERROR\");\r\n+        break;\r\n+\r\n+    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n+                           // for(i=0; i!=trigB; i++)\r\n+                           // {\r\n+                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n+                           //     UART0_SendByte(uart0_read_buf[i]);\r\n+                           // }\r\n+\r\n+        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n+        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n+        {\r\n+            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n+            {\r\n+                uart0_read_flag = 1;\r\n+                return;\r\n+            }\r\n+            uart0_read_len++;\r\n+        }\r\n+        break;\r\n+\r\n+    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n+        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n+        // i = UART0_RecvString(uart0_read_buf);\r\n+        // UART0_SendString( uart0_read_buf, i );\r\n+        break;\r\n+\r\n+    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n+        break;\r\n+\r\n+    case UART_II_MODEM_CHG: // 只支持串口0\r\n+        break;\r\n+\r\n+    default:\r\n+        break;\r\n+    }\r\n+}\r\n+\r\n+/******************************** endfile @ main ******************************/\r\n"
                },
                {
                    "date": 1677078627531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,10 @@\n     PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n     DelayMs(5);\r\n \r\n extern void bsp_key_register(void);\r\n-extern void bsp_key_register(void);\r\n+extern void bsp_led_register(void);\r\n+bsp_key_register();\r\n \r\n     app_uart_init();\r\n     app_led1_init();\r\n     app_key1_init();\r\n@@ -296,300 +297,4 @@\n     }\r\n }\r\n \r\n /******************************** endfile @ main ******************************/\r\n-/********************************** (C) COPYRIGHT *******************************\r\n- * File Name          : main.c\r\n- * Author             : WCH\r\n- * Version            : V1.1\r\n- * Date               : 2019/11/05\r\n- * Description        : 外设从机应用主函数及任务系统初始化\r\n- *******************************************************************************/\r\n-\r\n-/******************************************************************************/\r\n-/* 头文件包含 */\r\n-\r\n-#include \"CH57x_common.h\"\r\n-#include \"ch57x_usb_device_msc.h\"\r\n-#include \"ff.h\"\r\n-#include \"bsp_device.h\"\r\n-#include \"hal_spi.h\"\r\n-#include \"bsp_spi.h\"\r\n-#include \"bsp_log.h\"\r\n-#include \"app_flash.h\"\r\n-#include \"app_uart.h\"\r\n-#include \"app_led.h\"\r\n-#include \"app_key.h\"\r\n-#include \"hal_device.h\"\r\n-\r\n-FATFS fs;          /* FatFs文件系统对象 */\r\n-FIL fnew;          /* 文件对象 */\r\n-FRESULT res_flash; /* 文件操作结果 */\r\n-UINT fnum;         /* 文件成功读写数量 */\r\n-UINT8 uart0_read_len = 0;\r\n-UINT8 uart0_read_flag = 0;\r\n-UINT8 uart0_read_timeout = 0;\r\n-UINT8 uart0_read_buf[31] = {0};\r\n-BYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\n-BYTE WriteBuffer[] =         /* 写缓冲区*/\r\n-    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\n-BYTE WriteBuffer2[] = /* 写缓冲区*/\r\n-    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\n-UINT8 buf[512];\r\n-void DebugInit(void)\r\n-{\r\n-#if DEBUG == Debug_UART1\r\n-    GPIOA_SetBits(bTXD1);\r\n-    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n-    UART1_DefInit();\r\n-#elif DEBUG == Debug_UART0\r\n-    GPIOB_SetBits(bTXD0);\r\n-    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n-    GPIOB_SetBits(bRXD0);\r\n-    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n-\r\n-    UART0_DefInit();\r\n-    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n-    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n-    NVIC_EnableIRQ(UART0_IRQn);\r\n-#endif\r\n-}\r\n-\r\n-UINT8 work[4096];\r\n-int main()\r\n-{\r\n-    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n-    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n-    DelayMs(5);\r\n-    \r\n-    app_uart_init();\r\n-    app_led1_init();\r\n-    app_key1_init();\r\n-\r\n-    int led1_fd = bsp_device_open(\"led1\", 0);\r\n-    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n-    int key1_fd = bsp_device_open(\"key1\", 0);\r\n-\r\n-    hal_led_data_buff_t led_data = {\r\n-        .status = 1,\r\n-    };\r\n-    hal_uart_data_buff_t uart_msg = {\r\n-        .buff = WriteBuffer2,\r\n-        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n-    };\r\n-\r\n-    bsp_device_write(led1_fd, &led_data, 0);\r\n-    bsp_device_write(uart_fd, &uart_msg, 0);\r\n-\r\n-    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n-\r\n-    res_flash = f_mount(&fs, \"0:\", 1);\r\n-\r\n-    /*----------------------- 格式化测试 -----------------*/\r\n-    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n-    if (res_flash == FR_NO_FILESYSTEM)\r\n-    {\r\n-        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n-        /* 格式化 */\r\n-        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n-\r\n-        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n-\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n-            /* 格式化后，先取消挂载 */\r\n-            res_flash = f_mount(NULL, \"0:\", 1);\r\n-            /* 重新挂载\t*/\r\n-            res_flash = f_mount(&fs, \"0:\", 1);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"FLASH format error\\r\\n\");\r\n-            while (1)\r\n-                ;\r\n-        }\r\n-    }\r\n-    else if (res_flash != FR_OK)\r\n-    {\r\n-        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n-        app_flash_erase_all_flash();\r\n-        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n-        while (1)\r\n-            ;\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n-    }\r\n-\r\n-    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n-    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n-    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n-    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n-    if (res_flash == FR_OK)\r\n-    {\r\n-        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n-        /* 将指定存储区内容写入到文件内 */\r\n-        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n-            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n-        }\r\n-        /* 不再读写，关闭文件 */\r\n-        f_close(&fnew);\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"open/create file error\\r\\n\");\r\n-    }\r\n-\r\n-    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n-    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n-    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n-    if (res_flash == FR_OK)\r\n-    {\r\n-        LOG_INFO(\"open file ok\\r\\n\");\r\n-        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n-            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n-        }\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"open file error\\r\\n\");\r\n-    }\r\n-    /* 不再读写，关闭文件 */\r\n-    f_close(&fnew);\r\n-\r\n-    /* 不再使用文件系统，取消挂载文件系统 */\r\n-    f_mount(NULL, \"0:\", 1);\r\n-\r\n-    pEP0_RAM_Addr = EP0_Databuf;\r\n-    pEP1_RAM_Addr = EP1_Databuf;\r\n-    USB_DeviceInit();\r\n-    NVIC_EnableIRQ(USB_IRQn);\r\n-\r\n-    while (1)\r\n-    {\r\n-\r\n-        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n-        {\r\n-            DelayMs(20);\r\n-            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n-            {\r\n-                bsp_device_write(uart_fd, &uart_msg, 0);\r\n-                res_flash = f_mount(&fs, \"0:\", 1);\r\n-                if (res_flash == FR_OK)\r\n-                {\r\n-                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n-                }\r\n-                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n-                if (res_flash == FR_OK)\r\n-                {\r\n-                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n-                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n-                    if (res_flash == FR_OK)\r\n-                    {\r\n-                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n-                    }\r\n-                    else\r\n-                    {\r\n-                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n-                    }\r\n-                }\r\n-                while (1)\r\n-                {\r\n-                    if (uart0_read_flag == 1)\r\n-                    {\r\n-                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n-                        if (res_flash > 0)\r\n-                        {\r\n-                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n-                            f_close(&fnew);\r\n-                            f_mount(NULL, \"0:\", 1);\r\n-                        }\r\n-                        else\r\n-                        {\r\n-                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n-                        }\r\n-                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n-                        uart0_read_len = 0;\r\n-                        uart0_read_flag = 0;\r\n-                        break;\r\n-                    }\r\n-                    else\r\n-                    {\r\n-                        DelayMs(20);\r\n-                        uart0_read_timeout++;\r\n-                        if (uart0_read_timeout > 10)\r\n-                        {\r\n-                            uart0_read_timeout = 0;\r\n-                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n-                            uart0_read_len = 0;\r\n-                            uart0_read_flag = 0;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void UART0_IRQHandler(void)\r\n-{\r\n-    UINT8 i;\r\n-    switch (UART0_GetITFlag())\r\n-    {\r\n-    case UART_II_LINE_STAT: // 线路状态错误\r\n-        UART0_GetLinSTA();\r\n-        LOG_INFO(\"UART0 LINE ERROR\");\r\n-        break;\r\n-\r\n-    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n-                           // for(i=0; i!=trigB; i++)\r\n-                           // {\r\n-                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n-                           //     UART0_SendByte(uart0_read_buf[i]);\r\n-                           // }\r\n-\r\n-        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n-        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n-        {\r\n-            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n-            {\r\n-                uart0_read_flag = 1;\r\n-                return;\r\n-            }\r\n-            uart0_read_len++;\r\n-        }\r\n-        break;\r\n-\r\n-    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n-        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n-        // i = UART0_RecvString(uart0_read_buf);\r\n-        // UART0_SendString( uart0_read_buf, i );\r\n-        break;\r\n-\r\n-    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n-        break;\r\n-\r\n-    case UART_II_MODEM_CHG: // 只支持串口0\r\n-        break;\r\n-\r\n-    default:\r\n-        break;\r\n-    }\r\n-}\r\n-\r\n-/******************************** endfile @ main ******************************/\r\n"
                },
                {
                    "date": 1677078757143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,13 +64,12 @@\n \r\n extern void bsp_key_register(void);\r\n extern void bsp_led_register(void);\r\n bsp_key_register();\r\n+bsp_led_register();\r\n \r\n-    app_uart_init();\r\n-    app_led1_init();\r\n-    app_key1_init();\r\n \r\n+\r\n     int led1_fd = bsp_device_open(\"led1\", 0);\r\n     int uart_fd = bsp_device_open(\"uart0\", 0);\r\n     int key1_fd = bsp_device_open(\"key1\", 0);\r\n \r\n"
                },
                {
                    "date": 1677078766851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,14 +61,13 @@\n     SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n     PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n     DelayMs(5);\r\n \r\n-extern void bsp_key_register(void);\r\n-extern void bsp_led_register(void);\r\n-bsp_key_register();\r\n-bsp_led_register();\r\n \r\n \r\n+    app_uart_init();\r\n+    app_led1_init();\r\n+    app_key1_init();\r\n \r\n     int led1_fd = bsp_device_open(\"led1\", 0);\r\n     int uart_fd = bsp_device_open(\"uart0\", 0);\r\n     int key1_fd = bsp_device_open(\"key1\", 0);\r\n"
                },
                {
                    "date": 1677079186521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,12 +63,10 @@\n     DelayMs(5);\r\n \r\n \r\n \r\n-    app_uart_init();\r\n-    app_led1_init();\r\n-    app_key1_init();\r\n \r\n+\r\n     int led1_fd = bsp_device_open(\"led1\", 0);\r\n     int uart_fd = bsp_device_open(\"uart0\", 0);\r\n     int key1_fd = bsp_device_open(\"key1\", 0);\r\n \r\n@@ -82,8 +80,13 @@\n \r\n     bsp_device_write(led1_fd, &led_data, 0);\r\n     bsp_device_write(uart_fd, &uart_msg, 0);\r\n \r\n+extern void bsp_key_register(void);\r\n+extern void bsp_led_register(void);\r\n+bsp_key_register();\r\n+bsp_led_register();\r\n+\r\n     LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n \r\n     res_flash = f_mount(&fs, \"0:\", 1);\r\n \r\n"
                },
                {
                    "date": 1677079191943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,304 @@\n+/********************************** (C) COPYRIGHT *******************************\r\n+ * File Name          : main.c\r\n+ * Author             : WCH\r\n+ * Version            : V1.1\r\n+ * Date               : 2019/11/05\r\n+ * Description        : 外设从机应用主函数及任务系统初始化\r\n+ *******************************************************************************/\r\n+\r\n+/******************************************************************************/\r\n+/* 头文件包含 */\r\n+\r\n+#include \"CH57x_common.h\"\r\n+#include \"ch57x_usb_device_msc.h\"\r\n+#include \"ff.h\"\r\n+#include \"bsp_device.h\"\r\n+#include \"hal_spi.h\"\r\n+#include \"bsp_spi.h\"\r\n+#include \"bsp_log.h\"\r\n+#include \"app_flash.h\"\r\n+#include \"app_uart.h\"\r\n+#include \"app_led.h\"\r\n+#include \"app_key.h\"\r\n+#include \"hal_device.h\"\r\n+\r\n+FATFS fs;          /* FatFs文件系统对象 */\r\n+FIL fnew;          /* 文件对象 */\r\n+FRESULT res_flash; /* 文件操作结果 */\r\n+UINT fnum;         /* 文件成功读写数量 */\r\n+UINT8 uart0_read_len = 0;\r\n+UINT8 uart0_read_flag = 0;\r\n+UINT8 uart0_read_timeout = 0;\r\n+UINT8 uart0_read_buf[31] = {0};\r\n+BYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\n+BYTE WriteBuffer[] =         /* 写缓冲区*/\r\n+    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\n+BYTE WriteBuffer2[] = /* 写缓冲区*/\r\n+    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\n+UINT8 buf[512];\r\n+void DebugInit(void)\r\n+{\r\n+#if DEBUG == Debug_UART1\r\n+    GPIOA_SetBits(bTXD1);\r\n+    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n+    UART1_DefInit();\r\n+#elif DEBUG == Debug_UART0\r\n+    GPIOB_SetBits(bTXD0);\r\n+    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n+    GPIOB_SetBits(bRXD0);\r\n+    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n+\r\n+    UART0_DefInit();\r\n+    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n+    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n+    NVIC_EnableIRQ(UART0_IRQn);\r\n+#endif\r\n+}\r\n+\r\n+UINT8 work[4096];\r\n+int main()\r\n+{\r\n+    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n+    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n+    DelayMs(5);\r\n+\r\n+\r\n+\r\n+\r\n+    app_uart_init();\r\n+\r\n+    int led1_fd = bsp_device_open(\"led1\", 0);\r\n+    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n+    int key1_fd = bsp_device_open(\"key1\", 0);\r\n+\r\n+    hal_led_data_buff_t led_data = {\r\n+        .status = 1,\r\n+    };\r\n+    hal_uart_data_buff_t uart_msg = {\r\n+        .buff = WriteBuffer2,\r\n+        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n+    };\r\n+\r\n+    bsp_device_write(led1_fd, &led_data, 0);\r\n+    bsp_device_write(uart_fd, &uart_msg, 0);\r\n+\r\n+extern void bsp_key_register(void);\r\n+extern void bsp_led_register(void);\r\n+bsp_key_register();\r\n+bsp_led_register();\r\n+    app_led1_init();\r\n+    app_key1_init();\r\n+\r\n+    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n+\r\n+    res_flash = f_mount(&fs, \"0:\", 1);\r\n+\r\n+    /*----------------------- 格式化测试 -----------------*/\r\n+    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n+    if (res_flash == FR_NO_FILESYSTEM)\r\n+    {\r\n+        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n+        /* 格式化 */\r\n+        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n+\r\n+        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n+\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n+            /* 格式化后，先取消挂载 */\r\n+            res_flash = f_mount(NULL, \"0:\", 1);\r\n+            /* 重新挂载\t*/\r\n+            res_flash = f_mount(&fs, \"0:\", 1);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"FLASH format error\\r\\n\");\r\n+            while (1)\r\n+                ;\r\n+        }\r\n+    }\r\n+    else if (res_flash != FR_OK)\r\n+    {\r\n+        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n+        app_flash_erase_all_flash();\r\n+        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n+        while (1)\r\n+            ;\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n+    }\r\n+\r\n+    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n+    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n+    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n+    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n+    if (res_flash == FR_OK)\r\n+    {\r\n+        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n+        /* 将指定存储区内容写入到文件内 */\r\n+        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n+            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n+        }\r\n+        /* 不再读写，关闭文件 */\r\n+        f_close(&fnew);\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"open/create file error\\r\\n\");\r\n+    }\r\n+\r\n+    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n+    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n+    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n+    if (res_flash == FR_OK)\r\n+    {\r\n+        LOG_INFO(\"open file ok\\r\\n\");\r\n+        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n+            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n+        }\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"open file error\\r\\n\");\r\n+    }\r\n+    /* 不再读写，关闭文件 */\r\n+    f_close(&fnew);\r\n+\r\n+    /* 不再使用文件系统，取消挂载文件系统 */\r\n+    f_mount(NULL, \"0:\", 1);\r\n+\r\n+    pEP0_RAM_Addr = EP0_Databuf;\r\n+    pEP1_RAM_Addr = EP1_Databuf;\r\n+    USB_DeviceInit();\r\n+    NVIC_EnableIRQ(USB_IRQn);\r\n+\r\n+    while (1)\r\n+    {\r\n+\r\n+        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n+        {\r\n+            DelayMs(20);\r\n+            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n+            {\r\n+                bsp_device_write(uart_fd, &uart_msg, 0);\r\n+                res_flash = f_mount(&fs, \"0:\", 1);\r\n+                if (res_flash == FR_OK)\r\n+                {\r\n+                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n+                }\r\n+                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n+                if (res_flash == FR_OK)\r\n+                {\r\n+                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n+                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n+                    if (res_flash == FR_OK)\r\n+                    {\r\n+                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n+                    }\r\n+                }\r\n+                while (1)\r\n+                {\r\n+                    if (uart0_read_flag == 1)\r\n+                    {\r\n+                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n+                        if (res_flash > 0)\r\n+                        {\r\n+                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n+                            f_close(&fnew);\r\n+                            f_mount(NULL, \"0:\", 1);\r\n+                        }\r\n+                        else\r\n+                        {\r\n+                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n+                        }\r\n+                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n+                        uart0_read_len = 0;\r\n+                        uart0_read_flag = 0;\r\n+                        break;\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        DelayMs(20);\r\n+                        uart0_read_timeout++;\r\n+                        if (uart0_read_timeout > 10)\r\n+                        {\r\n+                            uart0_read_timeout = 0;\r\n+                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n+                            uart0_read_len = 0;\r\n+                            uart0_read_flag = 0;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void UART0_IRQHandler(void)\r\n+{\r\n+    UINT8 i;\r\n+    switch (UART0_GetITFlag())\r\n+    {\r\n+    case UART_II_LINE_STAT: // 线路状态错误\r\n+        UART0_GetLinSTA();\r\n+        LOG_INFO(\"UART0 LINE ERROR\");\r\n+        break;\r\n+\r\n+    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n+                           // for(i=0; i!=trigB; i++)\r\n+                           // {\r\n+                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n+                           //     UART0_SendByte(uart0_read_buf[i]);\r\n+                           // }\r\n+\r\n+        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n+        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n+        {\r\n+            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n+            {\r\n+                uart0_read_flag = 1;\r\n+                return;\r\n+            }\r\n+            uart0_read_len++;\r\n+        }\r\n+        break;\r\n+\r\n+    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n+        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n+        // i = UART0_RecvString(uart0_read_buf);\r\n+        // UART0_SendString( uart0_read_buf, i );\r\n+        break;\r\n+\r\n+    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n+        break;\r\n+\r\n+    case UART_II_MODEM_CHG: // 只支持串口0\r\n+        break;\r\n+\r\n+    default:\r\n+        break;\r\n+    }\r\n+}\r\n+\r\n+/******************************** endfile @ main ******************************/\r\n"
                },
                {
                    "date": 1677079198193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,314 +63,16 @@\n     DelayMs(5);\r\n \r\n \r\n \r\n-\r\n-    app_uart_init();\r\n-\r\n-    int led1_fd = bsp_device_open(\"led1\", 0);\r\n-    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n-    int key1_fd = bsp_device_open(\"key1\", 0);\r\n-\r\n-    hal_led_data_buff_t led_data = {\r\n-        .status = 1,\r\n-    };\r\n-    hal_uart_data_buff_t uart_msg = {\r\n-        .buff = WriteBuffer2,\r\n-        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n-    };\r\n-\r\n-    bsp_device_write(led1_fd, &led_data, 0);\r\n-    bsp_device_write(uart_fd, &uart_msg, 0);\r\n-\r\n extern void bsp_key_register(void);\r\n extern void bsp_led_register(void);\r\n bsp_key_register();\r\n bsp_led_register();\r\n     app_led1_init();\r\n     app_key1_init();\r\n+    app_uart_init();\r\n \r\n-    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n-\r\n-    res_flash = f_mount(&fs, \"0:\", 1);\r\n-\r\n-    /*----------------------- 格式化测试 -----------------*/\r\n-    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n-    if (res_flash == FR_NO_FILESYSTEM)\r\n-    {\r\n-        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n-        /* 格式化 */\r\n-        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n-\r\n-        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n-\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n-            /* 格式化后，先取消挂载 */\r\n-            res_flash = f_mount(NULL, \"0:\", 1);\r\n-            /* 重新挂载\t*/\r\n-            res_flash = f_mount(&fs, \"0:\", 1);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"FLASH format error\\r\\n\");\r\n-            while (1)\r\n-                ;\r\n-        }\r\n-    }\r\n-    else if (res_flash != FR_OK)\r\n-    {\r\n-        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n-        app_flash_erase_all_flash();\r\n-        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n-        while (1)\r\n-            ;\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n-    }\r\n-\r\n-    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n-    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n-    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n-    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n-    if (res_flash == FR_OK)\r\n-    {\r\n-        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n-        /* 将指定存储区内容写入到文件内 */\r\n-        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n-            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n-        }\r\n-        /* 不再读写，关闭文件 */\r\n-        f_close(&fnew);\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"open/create file error\\r\\n\");\r\n-    }\r\n-\r\n-    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n-    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n-    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n-    if (res_flash == FR_OK)\r\n-    {\r\n-        LOG_INFO(\"open file ok\\r\\n\");\r\n-        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n-            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n-        }\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"open file error\\r\\n\");\r\n-    }\r\n-    /* 不再读写，关闭文件 */\r\n-    f_close(&fnew);\r\n-\r\n-    /* 不再使用文件系统，取消挂载文件系统 */\r\n-    f_mount(NULL, \"0:\", 1);\r\n-\r\n-    pEP0_RAM_Addr = EP0_Databuf;\r\n-    pEP1_RAM_Addr = EP1_Databuf;\r\n-    USB_DeviceInit();\r\n-    NVIC_EnableIRQ(USB_IRQn);\r\n-\r\n-    while (1)\r\n-    {\r\n-\r\n-        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n-        {\r\n-            DelayMs(20);\r\n-            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n-            {\r\n-                bsp_device_write(uart_fd, &uart_msg, 0);\r\n-                res_flash = f_mount(&fs, \"0:\", 1);\r\n-                if (res_flash == FR_OK)\r\n-                {\r\n-                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n-                }\r\n-                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n-                if (res_flash == FR_OK)\r\n-                {\r\n-                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n-                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n-                    if (res_flash == FR_OK)\r\n-                    {\r\n-                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n-                    }\r\n-                    else\r\n-                    {\r\n-                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n-                    }\r\n-                }\r\n-                while (1)\r\n-                {\r\n-                    if (uart0_read_flag == 1)\r\n-                    {\r\n-                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n-                        if (res_flash > 0)\r\n-                        {\r\n-                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n-                            f_close(&fnew);\r\n-                            f_mount(NULL, \"0:\", 1);\r\n-                        }\r\n-                        else\r\n-                        {\r\n-                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n-                        }\r\n-                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n-                        uart0_read_len = 0;\r\n-                        uart0_read_flag = 0;\r\n-                        break;\r\n-                    }\r\n-                    else\r\n-                    {\r\n-                        DelayMs(20);\r\n-                        uart0_read_timeout++;\r\n-                        if (uart0_read_timeout > 10)\r\n-                        {\r\n-                            uart0_read_timeout = 0;\r\n-                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n-                            uart0_read_len = 0;\r\n-                            uart0_read_flag = 0;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void UART0_IRQHandler(void)\r\n-{\r\n-    UINT8 i;\r\n-    switch (UART0_GetITFlag())\r\n-    {\r\n-    case UART_II_LINE_STAT: // 线路状态错误\r\n-        UART0_GetLinSTA();\r\n-        LOG_INFO(\"UART0 LINE ERROR\");\r\n-        break;\r\n-\r\n-    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n-                           // for(i=0; i!=trigB; i++)\r\n-                           // {\r\n-                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n-                           //     UART0_SendByte(uart0_read_buf[i]);\r\n-                           // }\r\n-\r\n-        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n-        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n-        {\r\n-            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n-            {\r\n-                uart0_read_flag = 1;\r\n-                return;\r\n-            }\r\n-            uart0_read_len++;\r\n-        }\r\n-        break;\r\n-\r\n-    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n-        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n-        // i = UART0_RecvString(uart0_read_buf);\r\n-        // UART0_SendString( uart0_read_buf, i );\r\n-        break;\r\n-\r\n-    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n-        break;\r\n-\r\n-    case UART_II_MODEM_CHG: // 只支持串口0\r\n-        break;\r\n-\r\n-    default:\r\n-        break;\r\n-    }\r\n-}\r\n-\r\n-/******************************** endfile @ main ******************************/\r\n-/********************************** (C) COPYRIGHT *******************************\r\n- * File Name          : main.c\r\n- * Author             : WCH\r\n- * Version            : V1.1\r\n- * Date               : 2019/11/05\r\n- * Description        : 外设从机应用主函数及任务系统初始化\r\n- *******************************************************************************/\r\n-\r\n-/******************************************************************************/\r\n-/* 头文件包含 */\r\n-\r\n-#include \"CH57x_common.h\"\r\n-#include \"ch57x_usb_device_msc.h\"\r\n-#include \"ff.h\"\r\n-#include \"bsp_device.h\"\r\n-#include \"hal_spi.h\"\r\n-#include \"bsp_spi.h\"\r\n-#include \"bsp_log.h\"\r\n-#include \"app_flash.h\"\r\n-#include \"app_uart.h\"\r\n-#include \"app_led.h\"\r\n-#include \"app_key.h\"\r\n-#include \"hal_device.h\"\r\n-\r\n-FATFS fs;          /* FatFs文件系统对象 */\r\n-FIL fnew;          /* 文件对象 */\r\n-FRESULT res_flash; /* 文件操作结果 */\r\n-UINT fnum;         /* 文件成功读写数量 */\r\n-UINT8 uart0_read_len = 0;\r\n-UINT8 uart0_read_flag = 0;\r\n-UINT8 uart0_read_timeout = 0;\r\n-UINT8 uart0_read_buf[31] = {0};\r\n-BYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\n-BYTE WriteBuffer[] =         /* 写缓冲区*/\r\n-    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\n-BYTE WriteBuffer2[] = /* 写缓冲区*/\r\n-    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\n-UINT8 buf[512];\r\n-void DebugInit(void)\r\n-{\r\n-#if DEBUG == Debug_UART1\r\n-    GPIOA_SetBits(bTXD1);\r\n-    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n-    UART1_DefInit();\r\n-#elif DEBUG == Debug_UART0\r\n-    GPIOB_SetBits(bTXD0);\r\n-    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n-    GPIOB_SetBits(bRXD0);\r\n-    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n-\r\n-    UART0_DefInit();\r\n-    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n-    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n-    NVIC_EnableIRQ(UART0_IRQn);\r\n-#endif\r\n-}\r\n-\r\n-UINT8 work[4096];\r\n-int main()\r\n-{\r\n-    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n-    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n-    DelayMs(5);\r\n-\r\n-\r\n-\r\n-\r\n-\r\n     int led1_fd = bsp_device_open(\"led1\", 0);\r\n     int uart_fd = bsp_device_open(\"uart0\", 0);\r\n     int key1_fd = bsp_device_open(\"key1\", 0);\r\n \r\n@@ -384,13 +86,10 @@\n \r\n     bsp_device_write(led1_fd, &led_data, 0);\r\n     bsp_device_write(uart_fd, &uart_msg, 0);\r\n \r\n-extern void bsp_key_register(void);\r\n-extern void bsp_led_register(void);\r\n-bsp_key_register();\r\n-bsp_led_register();\r\n \r\n+\r\n     LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n \r\n     res_flash = f_mount(&fs, \"0:\", 1);\r\n \r\n"
                },
                {
                    "date": 1677079216098,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,304 @@\n+/********************************** (C) COPYRIGHT *******************************\r\n+ * File Name          : main.c\r\n+ * Author             : WCH\r\n+ * Version            : V1.1\r\n+ * Date               : 2019/11/05\r\n+ * Description        : 外设从机应用主函数及任务系统初始化\r\n+ *******************************************************************************/\r\n+\r\n+/******************************************************************************/\r\n+/* 头文件包含 */\r\n+\r\n+#include \"CH57x_common.h\"\r\n+#include \"ch57x_usb_device_msc.h\"\r\n+#include \"ff.h\"\r\n+#include \"bsp_device.h\"\r\n+#include \"hal_spi.h\"\r\n+#include \"bsp_spi.h\"\r\n+#include \"bsp_log.h\"\r\n+#include \"app_flash.h\"\r\n+#include \"app_uart.h\"\r\n+#include \"app_led.h\"\r\n+#include \"app_key.h\"\r\n+#include \"hal_device.h\"\r\n+\r\n+FATFS fs;          /* FatFs文件系统对象 */\r\n+FIL fnew;          /* 文件对象 */\r\n+FRESULT res_flash; /* 文件操作结果 */\r\n+UINT fnum;         /* 文件成功读写数量 */\r\n+UINT8 uart0_read_len = 0;\r\n+UINT8 uart0_read_flag = 0;\r\n+UINT8 uart0_read_timeout = 0;\r\n+UINT8 uart0_read_buf[31] = {0};\r\n+BYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\n+BYTE WriteBuffer[] =         /* 写缓冲区*/\r\n+    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\n+BYTE WriteBuffer2[] = /* 写缓冲区*/\r\n+    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\n+UINT8 buf[512];\r\n+void DebugInit(void)\r\n+{\r\n+#if DEBUG == Debug_UART1\r\n+    GPIOA_SetBits(bTXD1);\r\n+    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n+    UART1_DefInit();\r\n+#elif DEBUG == Debug_UART0\r\n+    GPIOB_SetBits(bTXD0);\r\n+    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n+    GPIOB_SetBits(bRXD0);\r\n+    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n+\r\n+    UART0_DefInit();\r\n+    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n+    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n+    NVIC_EnableIRQ(UART0_IRQn);\r\n+#endif\r\n+}\r\n+\r\n+UINT8 work[4096];\r\n+int main()\r\n+{\r\n+    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n+    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n+    DelayMs(5);\r\n+\r\n+\r\n+\r\n+    app_uart_init();\r\n+extern void bsp_key_register(void);\r\n+extern void bsp_led_register(void);\r\n+bsp_key_register();\r\n+bsp_led_register();\r\n+    app_led1_init();\r\n+    app_key1_init();\r\n+\r\n+    int led1_fd = bsp_device_open(\"led1\", 0);\r\n+    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n+    int key1_fd = bsp_device_open(\"key1\", 0);\r\n+\r\n+    hal_led_data_buff_t led_data = {\r\n+        .status = 1,\r\n+    };\r\n+    hal_uart_data_buff_t uart_msg = {\r\n+        .buff = WriteBuffer2,\r\n+        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n+    };\r\n+\r\n+    bsp_device_write(led1_fd, &led_data, 0);\r\n+    bsp_device_write(uart_fd, &uart_msg, 0);\r\n+\r\n+\r\n+\r\n+    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n+\r\n+    res_flash = f_mount(&fs, \"0:\", 1);\r\n+\r\n+    /*----------------------- 格式化测试 -----------------*/\r\n+    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n+    if (res_flash == FR_NO_FILESYSTEM)\r\n+    {\r\n+        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n+        /* 格式化 */\r\n+        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n+\r\n+        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n+\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n+            /* 格式化后，先取消挂载 */\r\n+            res_flash = f_mount(NULL, \"0:\", 1);\r\n+            /* 重新挂载\t*/\r\n+            res_flash = f_mount(&fs, \"0:\", 1);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"FLASH format error\\r\\n\");\r\n+            while (1)\r\n+                ;\r\n+        }\r\n+    }\r\n+    else if (res_flash != FR_OK)\r\n+    {\r\n+        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n+        app_flash_erase_all_flash();\r\n+        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n+        while (1)\r\n+            ;\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n+    }\r\n+\r\n+    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n+    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n+    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n+    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n+    if (res_flash == FR_OK)\r\n+    {\r\n+        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n+        /* 将指定存储区内容写入到文件内 */\r\n+        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n+            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n+        }\r\n+        /* 不再读写，关闭文件 */\r\n+        f_close(&fnew);\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"open/create file error\\r\\n\");\r\n+    }\r\n+\r\n+    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n+    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n+    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n+    if (res_flash == FR_OK)\r\n+    {\r\n+        LOG_INFO(\"open file ok\\r\\n\");\r\n+        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n+        if (res_flash == FR_OK)\r\n+        {\r\n+            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n+            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n+        }\r\n+        else\r\n+        {\r\n+            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n+        }\r\n+    }\r\n+    else\r\n+    {\r\n+        LOG_INFO(\"open file error\\r\\n\");\r\n+    }\r\n+    /* 不再读写，关闭文件 */\r\n+    f_close(&fnew);\r\n+\r\n+    /* 不再使用文件系统，取消挂载文件系统 */\r\n+    f_mount(NULL, \"0:\", 1);\r\n+\r\n+    pEP0_RAM_Addr = EP0_Databuf;\r\n+    pEP1_RAM_Addr = EP1_Databuf;\r\n+    USB_DeviceInit();\r\n+    NVIC_EnableIRQ(USB_IRQn);\r\n+\r\n+    while (1)\r\n+    {\r\n+\r\n+        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n+        {\r\n+            DelayMs(20);\r\n+            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n+            {\r\n+                bsp_device_write(uart_fd, &uart_msg, 0);\r\n+                res_flash = f_mount(&fs, \"0:\", 1);\r\n+                if (res_flash == FR_OK)\r\n+                {\r\n+                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n+                }\r\n+                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n+                if (res_flash == FR_OK)\r\n+                {\r\n+                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n+                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n+                    if (res_flash == FR_OK)\r\n+                    {\r\n+                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n+                    }\r\n+                }\r\n+                while (1)\r\n+                {\r\n+                    if (uart0_read_flag == 1)\r\n+                    {\r\n+                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n+                        if (res_flash > 0)\r\n+                        {\r\n+                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n+                            f_close(&fnew);\r\n+                            f_mount(NULL, \"0:\", 1);\r\n+                        }\r\n+                        else\r\n+                        {\r\n+                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n+                        }\r\n+                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n+                        uart0_read_len = 0;\r\n+                        uart0_read_flag = 0;\r\n+                        break;\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        DelayMs(20);\r\n+                        uart0_read_timeout++;\r\n+                        if (uart0_read_timeout > 10)\r\n+                        {\r\n+                            uart0_read_timeout = 0;\r\n+                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n+                            uart0_read_len = 0;\r\n+                            uart0_read_flag = 0;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+void UART0_IRQHandler(void)\r\n+{\r\n+    UINT8 i;\r\n+    switch (UART0_GetITFlag())\r\n+    {\r\n+    case UART_II_LINE_STAT: // 线路状态错误\r\n+        UART0_GetLinSTA();\r\n+        LOG_INFO(\"UART0 LINE ERROR\");\r\n+        break;\r\n+\r\n+    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n+                           // for(i=0; i!=trigB; i++)\r\n+                           // {\r\n+                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n+                           //     UART0_SendByte(uart0_read_buf[i]);\r\n+                           // }\r\n+\r\n+        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n+        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n+        {\r\n+            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n+            {\r\n+                uart0_read_flag = 1;\r\n+                return;\r\n+            }\r\n+            uart0_read_len++;\r\n+        }\r\n+        break;\r\n+\r\n+    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n+        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n+        // i = UART0_RecvString(uart0_read_buf);\r\n+        // UART0_SendString( uart0_read_buf, i );\r\n+        break;\r\n+\r\n+    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n+        break;\r\n+\r\n+    case UART_II_MODEM_CHG: // 只支持串口0\r\n+        break;\r\n+\r\n+    default:\r\n+        break;\r\n+    }\r\n+}\r\n+\r\n+/******************************** endfile @ main ******************************/\r\n"
                },
                {
                    "date": 1677079299078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,316 +66,12 @@\n \r\n     app_uart_init();\r\n extern void bsp_key_register(void);\r\n extern void bsp_led_register(void);\r\n-bsp_key_register();\r\n bsp_led_register();\r\n-    app_led1_init();\r\n-    app_key1_init();\r\n-\r\n-    int led1_fd = bsp_device_open(\"led1\", 0);\r\n-    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n-    int key1_fd = bsp_device_open(\"key1\", 0);\r\n-\r\n-    hal_led_data_buff_t led_data = {\r\n-        .status = 1,\r\n-    };\r\n-    hal_uart_data_buff_t uart_msg = {\r\n-        .buff = WriteBuffer2,\r\n-        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n-    };\r\n-\r\n-    bsp_device_write(led1_fd, &led_data, 0);\r\n-    bsp_device_write(uart_fd, &uart_msg, 0);\r\n-\r\n-\r\n-\r\n-    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n-\r\n-    res_flash = f_mount(&fs, \"0:\", 1);\r\n-\r\n-    /*----------------------- 格式化测试 -----------------*/\r\n-    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n-    if (res_flash == FR_NO_FILESYSTEM)\r\n-    {\r\n-        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n-        /* 格式化 */\r\n-        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n-\r\n-        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n-\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n-            /* 格式化后，先取消挂载 */\r\n-            res_flash = f_mount(NULL, \"0:\", 1);\r\n-            /* 重新挂载\t*/\r\n-            res_flash = f_mount(&fs, \"0:\", 1);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"FLASH format error\\r\\n\");\r\n-            while (1)\r\n-                ;\r\n-        }\r\n-    }\r\n-    else if (res_flash != FR_OK)\r\n-    {\r\n-        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n-        app_flash_erase_all_flash();\r\n-        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n-        while (1)\r\n-            ;\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n-    }\r\n-\r\n-    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n-    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n-    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n-    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n-    if (res_flash == FR_OK)\r\n-    {\r\n-        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n-        /* 将指定存储区内容写入到文件内 */\r\n-        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n-            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n-        }\r\n-        /* 不再读写，关闭文件 */\r\n-        f_close(&fnew);\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"open/create file error\\r\\n\");\r\n-    }\r\n-\r\n-    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n-    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n-    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n-    if (res_flash == FR_OK)\r\n-    {\r\n-        LOG_INFO(\"open file ok\\r\\n\");\r\n-        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n-        if (res_flash == FR_OK)\r\n-        {\r\n-            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n-            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n-        }\r\n-        else\r\n-        {\r\n-            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n-        }\r\n-    }\r\n-    else\r\n-    {\r\n-        LOG_INFO(\"open file error\\r\\n\");\r\n-    }\r\n-    /* 不再读写，关闭文件 */\r\n-    f_close(&fnew);\r\n-\r\n-    /* 不再使用文件系统，取消挂载文件系统 */\r\n-    f_mount(NULL, \"0:\", 1);\r\n-\r\n-    pEP0_RAM_Addr = EP0_Databuf;\r\n-    pEP1_RAM_Addr = EP1_Databuf;\r\n-    USB_DeviceInit();\r\n-    NVIC_EnableIRQ(USB_IRQn);\r\n-\r\n-    while (1)\r\n-    {\r\n-\r\n-        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n-        {\r\n-            DelayMs(20);\r\n-            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n-            {\r\n-                bsp_device_write(uart_fd, &uart_msg, 0);\r\n-                res_flash = f_mount(&fs, \"0:\", 1);\r\n-                if (res_flash == FR_OK)\r\n-                {\r\n-                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n-                }\r\n-                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n-                if (res_flash == FR_OK)\r\n-                {\r\n-                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n-                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n-                    if (res_flash == FR_OK)\r\n-                    {\r\n-                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n-                    }\r\n-                    else\r\n-                    {\r\n-                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n-                    }\r\n-                }\r\n-                while (1)\r\n-                {\r\n-                    if (uart0_read_flag == 1)\r\n-                    {\r\n-                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n-                        if (res_flash > 0)\r\n-                        {\r\n-                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n-                            f_close(&fnew);\r\n-                            f_mount(NULL, \"0:\", 1);\r\n-                        }\r\n-                        else\r\n-                        {\r\n-                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n-                        }\r\n-                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n-                        uart0_read_len = 0;\r\n-                        uart0_read_flag = 0;\r\n-                        break;\r\n-                    }\r\n-                    else\r\n-                    {\r\n-                        DelayMs(20);\r\n-                        uart0_read_timeout++;\r\n-                        if (uart0_read_timeout > 10)\r\n-                        {\r\n-                            uart0_read_timeout = 0;\r\n-                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n-                            uart0_read_len = 0;\r\n-                            uart0_read_flag = 0;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void UART0_IRQHandler(void)\r\n-{\r\n-    UINT8 i;\r\n-    switch (UART0_GetITFlag())\r\n-    {\r\n-    case UART_II_LINE_STAT: // 线路状态错误\r\n-        UART0_GetLinSTA();\r\n-        LOG_INFO(\"UART0 LINE ERROR\");\r\n-        break;\r\n-\r\n-    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n-                           // for(i=0; i!=trigB; i++)\r\n-                           // {\r\n-                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n-                           //     UART0_SendByte(uart0_read_buf[i]);\r\n-                           // }\r\n-\r\n-        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n-        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n-        {\r\n-            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n-            {\r\n-                uart0_read_flag = 1;\r\n-                return;\r\n-            }\r\n-            uart0_read_len++;\r\n-        }\r\n-        break;\r\n-\r\n-    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n-        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n-        // i = UART0_RecvString(uart0_read_buf);\r\n-        // UART0_SendString( uart0_read_buf, i );\r\n-        break;\r\n-\r\n-    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n-        break;\r\n-\r\n-    case UART_II_MODEM_CHG: // 只支持串口0\r\n-        break;\r\n-\r\n-    default:\r\n-        break;\r\n-    }\r\n-}\r\n-\r\n-/******************************** endfile @ main ******************************/\r\n-/********************************** (C) COPYRIGHT *******************************\r\n- * File Name          : main.c\r\n- * Author             : WCH\r\n- * Version            : V1.1\r\n- * Date               : 2019/11/05\r\n- * Description        : 外设从机应用主函数及任务系统初始化\r\n- *******************************************************************************/\r\n-\r\n-/******************************************************************************/\r\n-/* 头文件包含 */\r\n-\r\n-#include \"CH57x_common.h\"\r\n-#include \"ch57x_usb_device_msc.h\"\r\n-#include \"ff.h\"\r\n-#include \"bsp_device.h\"\r\n-#include \"hal_spi.h\"\r\n-#include \"bsp_spi.h\"\r\n-#include \"bsp_log.h\"\r\n-#include \"app_flash.h\"\r\n-#include \"app_uart.h\"\r\n-#include \"app_led.h\"\r\n-#include \"app_key.h\"\r\n-#include \"hal_device.h\"\r\n-\r\n-FATFS fs;          /* FatFs文件系统对象 */\r\n-FIL fnew;          /* 文件对象 */\r\n-FRESULT res_flash; /* 文件操作结果 */\r\n-UINT fnum;         /* 文件成功读写数量 */\r\n-UINT8 uart0_read_len = 0;\r\n-UINT8 uart0_read_flag = 0;\r\n-UINT8 uart0_read_timeout = 0;\r\n-UINT8 uart0_read_buf[31] = {0};\r\n-BYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\n-BYTE WriteBuffer[] =         /* 写缓冲区*/\r\n-    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\n-BYTE WriteBuffer2[] = /* 写缓冲区*/\r\n-    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\n-UINT8 buf[512];\r\n-void DebugInit(void)\r\n-{\r\n-#if DEBUG == Debug_UART1\r\n-    GPIOA_SetBits(bTXD1);\r\n-    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n-    UART1_DefInit();\r\n-#elif DEBUG == Debug_UART0\r\n-    GPIOB_SetBits(bTXD0);\r\n-    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n-    GPIOB_SetBits(bRXD0);\r\n-    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n-\r\n-    UART0_DefInit();\r\n-    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n-    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n-    NVIC_EnableIRQ(UART0_IRQn);\r\n-#endif\r\n-}\r\n-\r\n-UINT8 work[4096];\r\n-int main()\r\n-{\r\n-    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n-    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n-    DelayMs(5);\r\n-\r\n-\r\n-\r\n-extern void bsp_key_register(void);\r\n-extern void bsp_led_register(void);\r\n bsp_key_register();\r\n-bsp_led_register();\r\n     app_led1_init();\r\n     app_key1_init();\r\n-    app_uart_init();\r\n \r\n     int led1_fd = bsp_device_open(\"led1\", 0);\r\n     int uart_fd = bsp_device_open(\"uart0\", 0);\r\n     int key1_fd = bsp_device_open(\"key1\", 0);\r\n"
                },
                {
                    "date": 1677079520173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,9 +83,9 @@\n         .buff = WriteBuffer2,\r\n         .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n     };\r\n \r\n-    bsp_device_write(led1_fd, &led_data, 0);\r\n+    // bsp_device_write(led1_fd, &led_data, 0);\r\n     bsp_device_write(uart_fd, &uart_msg, 0);\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1677083761880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,10 +64,9 @@\n \r\n \r\n \r\n     app_uart_init();\r\n-extern void bsp_key_register(void);\r\n-extern void bsp_led_register(void);\r\n+\r\n bsp_led_register();\r\n bsp_key_register();\r\n     app_led1_init();\r\n     app_key1_init();\r\n@@ -84,9 +83,9 @@\n         .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n     };\r\n \r\n     // bsp_device_write(led1_fd, &led_data, 0);\r\n-    bsp_device_write(uart_fd, &uart_msg, 0);\r\n+    // bsp_device_write(uart_fd, &uart_msg, 0);\r\n \r\n \r\n \r\n     LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n"
                }
            ],
            "date": 1677078262329,
            "name": "Commit-0",
            "content": "/********************************** (C) COPYRIGHT *******************************\r\n * File Name          : main.c\r\n * Author             : WCH\r\n * Version            : V1.1\r\n * Date               : 2019/11/05\r\n * Description        : 外设从机应用主函数及任务系统初始化\r\n *******************************************************************************/\r\n\r\n/******************************************************************************/\r\n/* 头文件包含 */\r\n\r\n#include \"CH57x_common.h\"\r\n#include \"ch57x_usb_device_msc.h\"\r\n#include \"ff.h\"\r\n#include \"bsp_device.h\"\r\n#include \"hal_spi.h\"\r\n#include \"bsp_spi.h\"\r\n#include \"bsp_log.h\"\r\n#include \"app_flash.h\"\r\n#include \"app_uart.h\"\r\n#include \"app_led.h\"\r\n#include \"app_key.h\"\r\n#include \"hal_device.h\"\r\n\r\nFATFS fs;          /* FatFs文件系统对象 */\r\nFIL fnew;          /* 文件对象 */\r\nFRESULT res_flash; /* 文件操作结果 */\r\nUINT fnum;         /* 文件成功读写数量 */\r\nUINT8 uart0_read_len = 0;\r\nUINT8 uart0_read_flag = 0;\r\nUINT8 uart0_read_timeout = 0;\r\nUINT8 uart0_read_buf[31] = {0};\r\nBYTE ReadBuffer[1024] = {0}; /* 读缓冲区 */\r\nBYTE WriteBuffer[] =         /* 写缓冲区*/\r\n    \"fatfs test !!!!!!!!!!!!\\r\\n\";\r\nBYTE WriteBuffer2[] = /* 写缓冲区*/\r\n    \"asdfghjklzxcvbnmqwertyuiop\\r\\n\";\r\nUINT8 buf[512];\r\nvoid DebugInit(void)\r\n{\r\n#if DEBUG == Debug_UART1\r\n    GPIOA_SetBits(bTXD1);\r\n    GPIOA_ModeCfg(bTXD1, GPIO_ModeOut_PP_5mA);\r\n    UART1_DefInit();\r\n#elif DEBUG == Debug_UART0\r\n    GPIOB_SetBits(bTXD0);\r\n    GPIOB_ModeCfg(bTXD0, GPIO_ModeOut_PP_5mA);\r\n    GPIOB_SetBits(bRXD0);\r\n    GPIOB_ModeCfg(bRXD0, GPIO_ModeIN_PU);\r\n\r\n    UART0_DefInit();\r\n    UART0_ByteTrigCfg(UART_1BYTE_TRIG);\r\n    UART0_INTCfg(ENABLE, RB_IER_LINE_STAT | RB_IER_RECV_RDY);\r\n    NVIC_EnableIRQ(UART0_IRQn);\r\n#endif\r\n}\r\n\r\nUINT8 work[4096];\r\nint main()\r\n{\r\n    SetSysClock(CLK_SOURCE_HSE_32MHz);\r\n    PWR_UnitModCfg(ENABLE, UNIT_SYS_PLL); // ��PLL\r\n    DelayMs(5);\r\n\r\n    app_uart_init();\r\n    app_led1_init();\r\n    app_key1_init();\r\n\r\n    int led1_fd = bsp_device_open(\"led1\", 0);\r\n    int uart_fd = bsp_device_open(\"uart0\", 0);\r\n    int key1_fd = bsp_device_open(\"key1\", 0);\r\n\r\n    hal_led_data_buff_t led_data = {\r\n        .status = 1,\r\n    };\r\n    hal_uart_data_buff_t uart_msg = {\r\n        .buff = WriteBuffer2,\r\n        .len = sizeof(\"asdfghjklzxcvbnmqwertyuiop\\r\\n\"),\r\n    };\r\n\r\n    bsp_device_write(led1_fd, &led_data, 0);\r\n    bsp_device_write(uart_fd, &uart_msg, 0);\r\n\r\n    LOG_INFO(\"Start @ChipID=%02X\\n\", R8_CHIP_ID);\r\n\r\n    res_flash = f_mount(&fs, \"0:\", 1);\r\n\r\n    /*----------------------- 格式化测试 -----------------*/\r\n    /* 如果没有文件系统就格式化创建创建文件系统 */\r\n    if (res_flash == FR_NO_FILESYSTEM)\r\n    {\r\n        LOG_INFO(\"FLASH does not have a file system yet, it will be formatted soon ...\\r\\n\");\r\n        /* 格式化 */\r\n        res_flash = f_mkfs(\"0:\", FM_FAT, 0, work, sizeof(work));\r\n\r\n        LOG_INFO(\"f_mkfs ret: %d\\n\", res_flash);\r\n\r\n        if (res_flash == FR_OK)\r\n        {\r\n            LOG_INFO(\"FLASH have a file system yet\\r\\n\");\r\n            /* 格式化后，先取消挂载 */\r\n            res_flash = f_mount(NULL, \"0:\", 1);\r\n            /* 重新挂载\t*/\r\n            res_flash = f_mount(&fs, \"0:\", 1);\r\n        }\r\n        else\r\n        {\r\n            LOG_INFO(\"FLASH format error\\r\\n\");\r\n            while (1)\r\n                ;\r\n        }\r\n    }\r\n    else if (res_flash != FR_OK)\r\n    {\r\n        LOG_ERROR(\"external FLASH mount file system error, code :%d\\r\\n\", res_flash);\r\n        app_flash_erase_all_flash();\r\n        LOG_ERROR(\"erase all flash, wait for reset device...\\r\\n\");\r\n        while (1)\r\n            ;\r\n    }\r\n    else\r\n    {\r\n        LOG_INFO(\"file system mount ok, Read and write tests are available\");\r\n    }\r\n\r\n    /*----------------------- 文件系统测试：写测试 -------------------*/\r\n    /* 打开文件，每次都以新建的形式打开，属性为可写 */\r\n    LOG_INFO(\"\\r\\n****** File write test is about to be performed... ******\\r\\n\");\r\n    res_flash = f_open(&fnew, \"0:test.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n    if (res_flash == FR_OK)\r\n    {\r\n        LOG_INFO(\"open/create FatFs read/write test file, \\\"test.txt\\\" create ok, write date to this file\\r\\n\");\r\n        /* 将指定存储区内容写入到文件内 */\r\n        res_flash = f_write(&fnew, WriteBuffer, sizeof(WriteBuffer), &fnum);\r\n        if (res_flash == FR_OK)\r\n        {\r\n            LOG_INFO(\"this file written ok, number of data: %d\\n\", fnum);\r\n            LOG_INFO(\"writed data as: \\r\\n%s\\r\\n\", WriteBuffer);\r\n        }\r\n        else\r\n        {\r\n            LOG_INFO(\"write file error, code: %d\\n\", res_flash);\r\n        }\r\n        /* 不再读写，关闭文件 */\r\n        f_close(&fnew);\r\n    }\r\n    else\r\n    {\r\n        LOG_INFO(\"open/create file error\\r\\n\");\r\n    }\r\n\r\n    /*------------------- 文件系统测试：读测试 --------------------------*/\r\n    LOG_INFO(\"****** File read test coming... ******\\r\\n\");\r\n    res_flash = f_open(&fnew, \"0:test.txt\", FA_OPEN_EXISTING | FA_READ);\r\n    if (res_flash == FR_OK)\r\n    {\r\n        LOG_INFO(\"open file ok\\r\\n\");\r\n        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);\r\n        if (res_flash == FR_OK)\r\n        {\r\n            LOG_INFO(\"The file was read successfully. Byte data was read: %d\\r\\n\", fnum);\r\n            LOG_INFO(\"The file data obtained by reading is:\\r\\n%s \\r\\n\", ReadBuffer);\r\n        }\r\n        else\r\n        {\r\n            LOG_INFO(\"read file error, code: %d\\n\", res_flash);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        LOG_INFO(\"open file error\\r\\n\");\r\n    }\r\n    /* 不再读写，关闭文件 */\r\n    f_close(&fnew);\r\n\r\n    /* 不再使用文件系统，取消挂载文件系统 */\r\n    f_mount(NULL, \"0:\", 1);\r\n\r\n    pEP0_RAM_Addr = EP0_Databuf;\r\n    pEP1_RAM_Addr = EP1_Databuf;\r\n    USB_DeviceInit();\r\n    NVIC_EnableIRQ(USB_IRQn);\r\n\r\n    while (1)\r\n    {\r\n\r\n        if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n        {\r\n            DelayMs(20);\r\n            if (bsp_device_read(key1_fd, NULL, 0) == 0)\r\n            {\r\n                bsp_device_write(uart_fd, &uart_msg, 0);\r\n                res_flash = f_mount(&fs, \"0:\", 1);\r\n                if (res_flash == FR_OK)\r\n                {\r\n                    LOG_INFO(\"f_mount file ok\\r\\n\");\r\n                }\r\n                res_flash = f_open(&fnew, \"0:log.txt\", FA_CREATE_ALWAYS | FA_WRITE);\r\n                if (res_flash == FR_OK)\r\n                {\r\n                    LOG_INFO(\"f_open file ok\\r\\n\");\r\n                    res_flash = f_printf(&fnew, \"%s\", \"test\\n\");\r\n                    if (res_flash == FR_OK)\r\n                    {\r\n                        LOG_INFO(\"f_printf file ok\\r\\n\");\r\n                    }\r\n                    else\r\n                    {\r\n                        LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n                    }\r\n                }\r\n                while (1)\r\n                {\r\n                    if (uart0_read_flag == 1)\r\n                    {\r\n                        res_flash = f_printf(&fnew, \"%s\\n\", uart0_read_buf);\r\n                        if (res_flash > 0)\r\n                        {\r\n                            LOG_INFO(\"f_printf file ok\\r\\n\");\r\n                            f_close(&fnew);\r\n                            f_mount(NULL, \"0:\", 1);\r\n                        }\r\n                        else\r\n                        {\r\n                            LOG_ERROR(\"f_printf file fail, err_code: %d\\r\\n\", res_flash);\r\n                        }\r\n                        UART0_SendString(uart0_read_buf, uart0_read_len);\r\n                        uart0_read_len = 0;\r\n                        uart0_read_flag = 0;\r\n                        break;\r\n                    }\r\n                    else\r\n                    {\r\n                        DelayMs(20);\r\n                        uart0_read_timeout++;\r\n                        if (uart0_read_timeout > 10)\r\n                        {\r\n                            uart0_read_timeout = 0;\r\n                            memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n                            uart0_read_len = 0;\r\n                            uart0_read_flag = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid UART0_IRQHandler(void)\r\n{\r\n    UINT8 i;\r\n    switch (UART0_GetITFlag())\r\n    {\r\n    case UART_II_LINE_STAT: // 线路状态错误\r\n        UART0_GetLinSTA();\r\n        LOG_INFO(\"UART0 LINE ERROR\");\r\n        break;\r\n\r\n    case UART_II_RECV_RDY: // 数据达到设置触发点\r\n                           // for(i=0; i!=trigB; i++)\r\n                           // {\r\n                           //     uart0_read_buf[i] = UART0_RecvByte();\r\n                           //     UART0_SendByte(uart0_read_buf[i]);\r\n                           // }\r\n\r\n        uart0_read_buf[uart0_read_len] = UART0_RecvByte();\r\n        if ((uart0_read_len < 1024) && (uart0_read_flag == 0))\r\n        {\r\n            if (uart0_read_buf[uart0_read_len] == '\\n')\r\n            {\r\n                uart0_read_flag = 1;\r\n                return;\r\n            }\r\n            uart0_read_len++;\r\n        }\r\n        break;\r\n\r\n    case UART_II_RECV_TOUT: // 接收超时，暂时一帧数据接收完成\r\n        // memset(uart0_read_buf, '\\0', sizeof(uart0_read_buf));\r\n        // i = UART0_RecvString(uart0_read_buf);\r\n        // UART0_SendString( uart0_read_buf, i );\r\n        break;\r\n\r\n    case UART_II_THR_EMPTY: // 发送缓存区空，可继续发送\r\n        break;\r\n\r\n    case UART_II_MODEM_CHG: // 只支持串口0\r\n        break;\r\n\r\n    default:\r\n        break;\r\n    }\r\n}\r\n\r\n/******************************** endfile @ main ******************************/\r\n"
        }
    ]
}